package lesson6_ParallelMapperImpl;


import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

import info.kgeorgiy.java.advanced.mapper.ParallelMapper;

public class ParallelMapperImpl implements ParallelMapper {

	private ThreadsQueue myThreadPool;
	int cntThreads;

	public ParallelMapperImpl(int cntThreads) {
		this.cntThreads = cntThreads;
		myThreadPool = new ThreadsQueue(cntThreads);
	}

	@Override
	public void close() throws InterruptedException {
		myThreadPool.stopAll();
	}


	@Override
	public <T, R> List<R> map(Function<? super T, ? extends R> funct, List<? extends T> list) throws InterruptedException {
		List<List<R>> results = new ArrayList<>();

		for (int i = 0; i < cntThreads; i++)  {
			results.add(new ArrayList<>());
		}
		int realCnt = cntThreads;
		int lenSublist = Integer.max(list.size() / cntThread, 1);
		for (int i = 0; i < cntThreads; i++) {
			if (lenSublist * i < list.size()) {
				final int pos = i;
				final List<? extends T> sl = list.subList(lenSublist * i,  Integer.min(lenSublist * (i + 1), list.size()));
				Runnable r = new Runnable() {
					public void run() {
						List<R> appl = new ArrayList<>();
						for (int j = 0; j < sl.size(); j++) {
							appl.add(funct.apply(sl.get(j)));
						}
						results.set(pos, appl);
						synchronized (results) {
							System.err.println("not"+pos + " " +results.get(pos).size() + " " + sl.size());
							results.notify();
						}
					}
				};
				myThreadPool.applyMap(r);
			} else {
				realCnt = i;
				break;
			}
		}
		for (int i = 0; i < realCnt; i++) {
				synchronized (results) {
					while (results.get(i).isEmpty()) {
					System.err.println(":((("+i);
					results.wait();
					System.err.println(":))"+i);
				}
			}
		}
		List<R> ans = new ArrayList<>();
		for (int i = 0; i < cntThreads; i++) {
			ans.addAll(results.get(i));
		}
		return ans;
	}

}
