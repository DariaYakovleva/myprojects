есть inner class
есть outer class

у inner есть доступ к своему и (outer class) *this
static у outer 	ничего не значит

можно определить вложенный класс nest
у него нет ссылки на outer this

implements interface

интерфейс реализует набор методов
абстрактный класс с чисто виртуальными функциями

никакие модификаторы писать нельзя

некоторые методы одинаковые в деталях реализации обоих стеков
не хотим писать больше

выделили общую часть


есть interface stack <- abstract class - абстрактный класс с полем size <- ArrayStack
есть interface stack <- abstract class - абстрактный класс с полем size <- LinkedStack


в джаве можно говорить, что interface - контракт,
а остальное - детали реализации

если есть два разных метода size то используется наиболее глубоко лежащий в иерархии

переопределение метода в потомке - > вызывается он или

public int size() {
	return super.size();
}


можно очень много интерфейсов
но может быть только один предок
так как для типа Object < - предок для всего
если не определен предок, то предком будет Object(у него предка нет), но он такой один

один интерфейс, один базовый класс нет дублирования